/*
DATS 5750 Project 2: Intelligent Cloud Translation Assistant
Frontend JavaScript Functionality

Purpose:
    This JavaScript file provides all client-side functionality for the Intelligent
    Cloud Translation Assistant web interface. It handles user interactions, file
    uploads, real-time progress tracking, and communication with the Flask backend
    to create a seamless user experience.

Key Features:
    - Drag-and-drop file upload with visual feedback
    - Real-time progress polling and status updates
    - File validation (type, size, content)
    - AJAX communication with backend API endpoints
    - Modal-based preview functionality for translations
    - Responsive toast notifications and error handling
    - Keyboard shortcuts and accessibility features
    - Browser compatibility and cross-platform support

Technical Implementation:
    - Vanilla JavaScript with modern ES6+ features
    - Bootstrap 5 integration for modals and components
    - Fetch API for asynchronous HTTP requests
    - Event-driven architecture with proper cleanup
    - Error recovery and retry mechanisms
    - Performance optimization with proper event handling

Author: Dennis Castro
Course: DATS 5750 - Introduction to Data Science and Analytics
Institution: University of Pennsylvania
Generated by: Claude AI (Anthropic)
Date: February 2026
*/

// JavaScript for Intelligent Cloud Translation Assistant

// Global variables
let currentFileId = null;
let statusCheckInterval = null;

// DOM elements
const uploadArea = document.getElementById('uploadArea');
const fileInput = document.getElementById('fileInput');
const browseButton = document.getElementById('browseButton');
const processingStatus = document.getElementById('processingStatus');
const statusMessage = document.getElementById('statusMessage');
const statusDetails = document.getElementById('statusDetails');
const resultsSection = document.getElementById('resultsSection');
const errorSection = document.getElementById('errorSection');
const errorMessage = document.getElementById('errorMessage');
const previewButton = document.getElementById('previewButton');
const downloadButton = document.getElementById('downloadButton');
const newTranslationButton = document.getElementById('newTranslationButton');
const previewModal = new bootstrap.Modal(document.getElementById('previewModal'));

// Initialize event listeners when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    initializeEventListeners();
});

function initializeEventListeners() {
    // File upload events
    browseButton.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', handleFileSelect);
    
    // Drag and drop events
    uploadArea.addEventListener('click', () => fileInput.click());
    uploadArea.addEventListener('dragover', handleDragOver);
    uploadArea.addEventListener('dragleave', handleDragLeave);
    uploadArea.addEventListener('drop', handleFileDrop);
    
    // Button events
    previewButton.addEventListener('click', showPreview);
    downloadButton.addEventListener('click', downloadTranslation);
    newTranslationButton.addEventListener('click', resetInterface);
    document.getElementById('downloadFromPreview').addEventListener('click', downloadTranslation);
    
    // Prevent default drag behaviors on document
    document.addEventListener('dragover', e => e.preventDefault());
    document.addEventListener('drop', e => e.preventDefault());
}

// Drag and drop handlers
function handleDragOver(e) {
    e.preventDefault();
    uploadArea.classList.add('drag-over');
}

function handleDragLeave(e) {
    e.preventDefault();
    uploadArea.classList.remove('drag-over');
}

function handleFileDrop(e) {
    e.preventDefault();
    uploadArea.classList.remove('drag-over');
    
    const files = e.dataTransfer.files;
    if (files.length > 0) {
        handleFileUpload(files[0]);
    }
}

function handleFileSelect(e) {
    const files = e.target.files;
    if (files.length > 0) {
        handleFileUpload(files[0]);
    }
}

// File upload and processing
function handleFileUpload(file) {
    // Validate file
    if (!validateFile(file)) {
        return;
    }
    
    // Show processing state
    showProcessingState();
    
    // Create form data
    const formData = new FormData();
    formData.append('file', file);
    
    // Update status
    updateStatus('Uploading file...', 'Please wait while we upload your document.');
    updateProgress(10);
    
    // Upload file
    fetch('/upload', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            currentFileId = data.file_id;
            updateStatus('Processing document...', 'Analyzing file and extracting text content.');
            updateProgress(30);
            startStatusPolling();
        } else {
            showError(data.error || 'Upload failed');
        }
    })
    .catch(error => {
        console.error('Upload error:', error);
        showError('Upload failed. Please try again.');
    });
}

function validateFile(file) {
    // Check file size (10MB limit)
    const maxSize = 10 * 1024 * 1024;
    if (file.size > maxSize) {
        showError('File too large. Maximum size is 10MB.');
        return false;
    }
    
    if (file.size === 0) {
        showError('File is empty. Please select a valid file.');
        return false;
    }
    
    // Check file type
    const allowedExtensions = ['.txt', '.html', '.md', '.pdf', '.jpg', '.jpeg', '.png', '.gif'];
    const fileName = file.name.toLowerCase();
    const isValidType = allowedExtensions.some(ext => fileName.endsWith(ext));
    
    if (!isValidType) {
        showError(`File type not supported. Allowed types: ${allowedExtensions.join(', ')}`);
        return false;
    }
    
    return true;
}

function startStatusPolling() {
    if (statusCheckInterval) {
        clearInterval(statusCheckInterval);
    }
    
    statusCheckInterval = setInterval(checkStatus, 3000); // Check every 3 seconds
    checkStatus(); // Initial check
}

function checkStatus() {
    if (!currentFileId) return;
    
    fetch(`/status/${currentFileId}`)
    .then(response => response.json())
    .then(data => {
        if (data.status === 'completed') {
            clearInterval(statusCheckInterval);
            showSuccess();
        } else if (data.status === 'processing') {
            updateStatus('Translating document...', data.message || 'AI translation in progress.');
            updateProgress(70);
        } else if (data.status === 'error') {
            clearInterval(statusCheckInterval);
            showError(data.message || 'Processing failed');
        }
    })
    .catch(error => {
        console.error('Status check error:', error);
        // Don't show error for network issues during polling
    });
}

// UI State Management
function showProcessingState() {
    hideAllSections();
    processingStatus.classList.remove('d-none');
    processingStatus.classList.add('fade-in-up');
}

function showSuccess() {
    updateProgress(100);
    setTimeout(() => {
        hideAllSections();
        resultsSection.classList.remove('d-none');
        resultsSection.classList.add('fade-in-up');
    }, 1000);
}

function showError(message) {
    hideAllSections();
    errorMessage.textContent = message;
    errorSection.classList.remove('d-none');
    errorSection.classList.add('fade-in-up');
    
    // Auto-hide error after 10 seconds
    setTimeout(() => {
        if (!errorSection.classList.contains('d-none')) {
            resetInterface();
        }
    }, 10000);
}

function updateStatus(title, details = '') {
    statusMessage.textContent = title;
    statusDetails.textContent = details;
}

function updateProgress(percentage) {
    const progressBar = document.querySelector('.progress-bar');
    progressBar.style.width = `${percentage}%`;
    progressBar.setAttribute('aria-valuenow', percentage);
}

function hideAllSections() {
    processingStatus.classList.add('d-none');
    resultsSection.classList.add('d-none');
    errorSection.classList.add('d-none');
    uploadArea.style.display = 'block';
}

function resetInterface() {
    // Clear intervals
    if (statusCheckInterval) {
        clearInterval(statusCheckInterval);
        statusCheckInterval = null;
    }
    
    // Reset variables
    currentFileId = null;
    
    // Reset file input
    fileInput.value = '';
    
    // Reset progress
    updateProgress(0);
    
    // Hide all sections and show upload area
    hideAllSections();
    uploadArea.style.display = 'block';
    
    // Remove any classes
    uploadArea.classList.remove('drag-over');
    
    // Scroll to top
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

// Preview and Download Functions
function showPreview() {
    if (!currentFileId) return;
    
    previewButton.disabled = true;
    previewButton.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Loading...';
    
    fetch(`/preview/${currentFileId}`)
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            document.getElementById('previewContent').textContent = data.content;
            previewModal.show();
        } else {
            showError(data.error || 'Preview failed');
        }
    })
    .catch(error => {
        console.error('Preview error:', error);
        showError('Preview failed. Please try again.');
    })
    .finally(() => {
        previewButton.disabled = false;
        previewButton.innerHTML = '<i class="fas fa-eye me-2"></i>Preview Translation';
    });
}

function downloadTranslation() {
    if (!currentFileId) return;
    
    const downloadUrl = `/download/${currentFileId}`;
    
    // Create temporary link for download
    const link = document.createElement('a');
    link.href = downloadUrl;
    link.style.display = 'none';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Show success message
    showToast('Download started successfully!', 'success');
}

// Utility Functions
function showToast(message, type = 'info') {
    // Create toast element
    const toastHtml = `
        <div class="toast align-items-center text-white bg-${type === 'success' ? 'success' : 'info'} border-0" role="alert">
            <div class="d-flex">
                <div class="toast-body">
                    <i class="fas fa-${type === 'success' ? 'check' : 'info'}-circle me-2"></i>
                    ${message}
                </div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
            </div>
        </div>
    `;
    
    // Add to toast container (create if doesn't exist)
    let toastContainer = document.getElementById('toastContainer');
    if (!toastContainer) {
        toastContainer = document.createElement('div');
        toastContainer.id = 'toastContainer';
        toastContainer.className = 'toast-container position-fixed top-0 end-0 p-3';
        toastContainer.style.zIndex = '1055';
        document.body.appendChild(toastContainer);
    }
    
    toastContainer.insertAdjacentHTML('beforeend', toastHtml);
    
    // Initialize and show toast
    const toastElement = toastContainer.lastElementChild;
    const toast = new bootstrap.Toast(toastElement, { delay: 4000 });
    toast.show();
    
    // Remove element after hiding
    toastElement.addEventListener('hidden.bs.toast', () => {
        toastElement.remove();
    });
}

// Format file size for display
function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// Add animation classes when elements come into view
function addScrollAnimations() {
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                entry.target.classList.add('fade-in-up');
            }
        });
    });
    
    // Observe elements for animation
    document.querySelectorAll('.feature-card').forEach(card => {
        observer.observe(card);
    });
}

// Initialize scroll animations when DOM is loaded
document.addEventListener('DOMContentLoaded', addScrollAnimations);

// Handle browser back/forward buttons
window.addEventListener('popstate', () => {
    resetInterface();
});

// Handle page visibility changes (pause polling when page is hidden)
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        if (statusCheckInterval) {
            clearInterval(statusCheckInterval);
        }
    } else {
        // Resume polling if we have a current file
        if (currentFileId && !resultsSection.classList.contains('d-none')) {
            startStatusPolling();
        }
    }
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
    // Escape key to reset interface
    if (e.key === 'Escape') {
        resetInterface();
    }
    
    // Enter key on upload area to browse files
    if (e.key === 'Enter' && document.activeElement === uploadArea) {
        fileInput.click();
    }
});

// Make upload area focusable for accessibility
uploadArea.setAttribute('tabindex', '0');
uploadArea.setAttribute('role', 'button');
uploadArea.setAttribute('aria-label', 'Click or drag files here to upload');

console.log('Translation Assistant JavaScript loaded successfully');
